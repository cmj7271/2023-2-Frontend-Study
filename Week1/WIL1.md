# week1

---

자바스크립트의 주요한 특징 

1. 인터프리터 언어이다.
이로 인해 느리다고  판단할 수도 있지만, JIT 컴파일러를 통해 실행 속도를 높였다고 한다.

1. 객체 지향을 지원한다.
단, C++, java 와는 다르게 클래스가 아닌, 프로토타입을 통해 지원한다.
프로토타입은 매소드와 프로퍼티를 동적으로 추가, 삭제 가능하다고 한다.

1. 동적 타입 언어이다.
자바스크립트는 변수 타입이 존재하지 않는다. 
파이썬의 경우 명시하지는 않지만, 한번 정해진 변수에는 타입이 고정되는데 ( 변환은 가능하지만),
설명으로는 동적으로 변경가능하다는데, 이것이 파이썬과 같은 의미인지는 알아봐야 할 거 같다.

1. 함수가 일급 객체이다.
일급 객체란 [영문 위키피디아](https://en.m.wikipedia.org/wiki/First-class_citizen)에 따르면, 다른 객체처럼 연산이 적용가능한 객체를 의미한다.
즉, `int`, `float`, `double` 등의 자료형에서처럼 기본 연산이 가능하며, 또한 함수의 인자, 반환값으로도 가능하다는 의미이다.

1. 함수가 클로저를 정의한다.
클로저에 대해 한 [사이트](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)를 참고해본 결과(다 이해하기는 좀 어려웠고…)
다른 언어랑은 스코프의 작동방식이 조금 다른 것 같았다. 또한, 이를 통해 비공개 메소드를 만든다는 점은 흥미로웠다.

## 변수

---

변수 선언은 기본적으로 `var` 이라는 키워드를 사용한다.
타입의 구분이 없으므로 모든 데이터를 저장가능하다.
만약 선언후 초기화하지 않는다면, `undefined` 라는 값이 저장된다.
`var` 로 선언하지 않고 바로 대입이 가능은 하다고 하지만… 전역변수로 선언되며, 오류를 일으킬 가능성이 높으므로 권장하지 않는다.

`호이스팅(hoisting)` 이라는 기능에 의해, 위치상 선언보다 사용이 먼저이더라도 오류가 나지 않고 실행된다.
단, 선언과 초기화가 동시에 이루어지면, 초기화된 값이 아니라 `undefined` 을 반환한다.

숫자는 기본적으로 64비트 부동소수점(`double`)으로 저장된다. 
또한 각종 2진법, 8진법, 16진법 표기법을 지원한다. 단, 2진법, 8진법은 ES6부터 지원한다는 점은 유의해야한다.

읽기 전용의 특별한 문자열이 존재한다.
`Infinity` : 양의 무한대, `const long long INF = 1 << 60` 과 비슷하다.
`NaN` : 부정 값..? (Not a Number), 0을 0 으로 나눈 결과값이라고 한다.

여기서부터는 모두 `Number` 의 프로퍼티이다.
`POSITIVE_INFINITY`, `NEGATIVE_INFINITY`, `MAX_VALUE`, `MIN_VALUE`, `NaN`,
`EPSILON`(대충 굉장히 작은 양의 소수), `MIN_SAFE_INTEGER`, `MAX_SAFE_INTEGER` 

문자열은 `’’`와 `””` 은 구분하지 않는다. 

이스케이프 시퀀스는 비슷하게 지원한다.

특수한 값으로는 `undefined` 와 `null` 이 존재한다.
`undefined` 는 ***값이 할당되지 않음*** 을, `null` 은 ***아무것도 없음*** 을 의미한다. 

## ECMAScript6 부터 추가된 데이터 타입

---

심벌
`var sym1 = Symbol();` 의 형식으로 만들 수 있다.
이 때, `sym1` 에는 고유의 값이 저장된다. (하지만, 내부에 저장된 값은 `undefined` 이다.)
이를 통해 코드의 가독성을 높일 수 있다.
예를 들어,  몇 권의 책을 숫자로 이루어진 코드로 구별하기로 했다고 하자.
모던자바스크립트입문 = 1, 리액트 어쩌구저쩌구 = 2…
어떤 책이 모던자바스크립트입문인지를 확인하고 싶다고 가정할 때, 
`book == 1` 로 확인할 것이다. 하지만, 이 코드만으로는 왜 1인지, 1이 무엇을 의미하는지 파악하기 어렵다.
그래서 그 대신에 `모던자바스크립트입문 = Symbol();` 이라고 선언한다면,
`book == 모던자바스크립트입문` 은 좀 더 직관적인 코드가 된다.
또한 () 안의 인자는 그 심벌에 대한 부가설명을 추가해줄 수 있다.

또한, 같은 심벌을 공유하고 싶은 경우에는 `Symbol.for(부가설명)` 을 통해 같은 부가설명인 심벌에 대해 공유할 수 있다.
주의) `Symbol(“club”) != Symbol.for(“club”);` 이다.
따라서, 심벌을 공유할 생각이라면 처음부터 `Symbol.for()` 을 사용해야 한다.

템플렛 리터럴

문자열 리터럴과 비슷하지만, 앞뒤로 ```` 로 감싼다는 점이 다르다.(`’’` 이나, `””` 이 아니다)
문자열과 다른 점은 입력한 그대로 출력할 수 있다는 것이다.
예를 들어 이스케이프 시퀀스인 `\n` 을 사용하지 않고, `enter` 를 통해 줄바꿈을 출력해 줄 수 있다.
물론 이스케이프 시퀀스는 사용가능하며, 만약 이스케이프 시퀀스를 그대로 출력하려면,
`String.raw``;` 로 표현해주면 된다. 
만약 변수를 추가하고 싶다면, `${…}` 를 사용해주면 된다. 

## 객체

---

원시 타입(앞에서 한 숫자, 문자열, 심벌…) 을 제외하고는 모두 객체이다.
파이썬에서는 모든 것이 객체라고 표현하는 것과는 차이가 있다.

객체 : 이름과 값을 한 쌍으로 묶은 데이터가 여러 개임
포함된 데이터쌍 하나를 ***프로퍼티*** 라고 한다.

객체 리터럴로 생성가능하다.
`var ${name} = { ${key} : ${value}, … }` 의 형식으로 생성가능하다.
접근은 `name.key` 혹은 `name[key]` 로 접근가능하다.
없는 `key` 로 접근시 `undefined` 를 반환한다.

생성 후 프로퍼티 추가가 가능하다. `name.key = value` , `name[key] = value` 의 형식이다.
`delete` 를 통해 제거도 가능하다. `delete name.key`, `delete name[key]`

`in` 연산자로 프로퍼티가 존재하는지 확인가능하다.
`key in name` 의 형식으로 `true / false` 를 반환한다.
주의점은 상속받은 모든 프로퍼티를 검사한다는 점이다.

객체는 ***참조*** 함으로서 저장한다는 점을 유념하자.

## 함수

---

`function ${name} (${var1}, ${var2}, ... ) {... return ${value} }` 의 형식이다.
대체로 python 과 유사하다.

함수의 사용이 선언보다 앞에 위치해도 잘 작동한다.

함수도 객체이므로, 함수를 참조하는 변수를 선언할 수 있다.
`var ${name} = ${function_name}` 의 형식으로 `name` 은 `function` 을 가르키는 변수이다.

유의할 점은 인수로서 넘기는 변수가 객체일 때이다.
객체는 기본적으로 ***참조*** 를 활용한다.
이에 함수는 ***참조값*** 을 전달받게 되고, 이는 복사된 변수의 변경가능성을 유발한다.

- 만약 함수가 받아야 할 변수가 너무 많으면 어떻게 간단하게 해결할 수 있을까?
함수가 받을 여러개의 변수들을 하나의 객체로 담아서 전달하면 된다.
이런 방법은 함수에서는 객체만 받으면 되므로 코드가 깔끔해지며,
순서에 구애받지 않아도 되므로 편하다.
단, 객체로 전달하기 때문에 원본이 훼손될 수 있다는 점을 유의해야 한다.

변수의  스코프는 다른 언어와 크게 다르지 않으나, ***변수의 끌어올림*** 도 생각해야 함을 주의한다.
전역 변수는 `${name} = ${value}` 즉, `var` 을 쓰지 않고 변수를 만들면 된다.

`let` 은 `var` 처럼 변수를 만들지만, 그 스코프가 `{}` 으로 한정된다는 점이 다르다.
`const` 는 상수를 만들 때 사용된다. 특이점은 객체에는 `const` 를 붙여도 프로퍼티 변경이 가능하다…

또한 함수는 리터럴로 선언하는 것이 가능하다.
`var ${name} = function(${var1}, ${var2}, … ) { … return ${value}; };`
익명 함수, 무명 함수라고 불리며, name이라는 변수에 함수 객체의 참조 형식으로 저장된다.
단, 할당된 후에 사용가능하므로, 이러한 형태의 변수는 ***끌어올림*** 이 적용되지 않음을 주의한다.

메서드에서 객체의 프로퍼티를 사용할 때는 `this` 를 객체이름 대신 사용해주면 된다.
객체 내의 메서드를 만들 수 있다. 기본적으로 자바스크립트는 프로퍼티와 메소드를 구분하지 않는다.

## 객체를 만드는 다른 방법

---

앞에서 객체를 만드는 방법으로 객체 리터럴을 알아보았다.
하지만 이런 방법은 비슷한 객체(프로퍼티는 같으나, 그 값만 다른 객체들) 을 만들 때는 
매번 코드를 반복하기 때문에 좋은 방법이라고 할 수는 없다.
다른 언어에서는 클래스 생성자라는 문법으로 하나의 틀을 제공하는데, 
사실 자바스크립트에는 생성자가 따로 존재하지는 않는다.
대신에 함수를 생성하는 방식을 가지고 있다.
`function ${obj_name} ( ${property_1_value}, ${property_2_value}, … ) {this.property_1 = property_1_value; … }` 의 형식으로 함수를 만들고,
`var ${instance_name} = new ${obj_name} (val_1, val_2, …);` 으로 `new` 키워드를 통해 만든다.

자바스크립트는 기본적으로 내장된 객체들을 지원한다.
또한 객체는 종류에 따라 ***네이티브 객체, 호스트 객체, 사용자 정의 객체*** 로 나뉜다고 한다.

## 배열

---

배열은 `var ${name} = [ val_1, val_2, ... ];` 으로 배열 리터럴을 사용할 수 있다.  
인덱스는 0-base 이며, 특이하게 배열 리터럴에서 값 생략이 가능하다.  
예를 들어, `var arr = [0, 1, , 3, 4];` 로 생성한다면, 2번째 index에는 `undefined` 가 저장된다.  
배열은 `length` 라는 프로퍼티가 존재하는데, 이는 일반적으로 다른 언어의 배열처럼 길이를 저장하지만,  
유의점이 존재한다. `length` 는 실제로는 최대 인덱스 + 1 라는 값을 가지는데,  
이것이 실제 길이와는 다른 경우가 존재한다고 한다. ( 아마 희소 배열이라는 것 같다.)  
또한 다른 언어와는 달리 배열은 메모리의 연속된 주소가 아닌 객체로 구현된 가상의 배열이다.  
그래서 원소 접근을 `arr["2"]` 식의 접근이 가능하다.  
추가로는 `arr.push(val)` 이 가능하고, 삭제는 `delete arr[1]` 의 형식으로 가능하다.  
이 때 주의할 점은 삭제시 그 위치는 `undefined` 로 바뀐다는 것이다.   
즉 길이 `length` 의 값이 변하지는 않는다.  
그 예시로는 희소 배열이 되는데,  
일반 배열에 원소를 추가, 삭제하는 경우 발생할 수 있다.  
예시로 `var arr = [0, 1, 2, 3, 4]` 를 들어보자.  
이 배열에 `arr[6] = 6`  이라는 원소를 추가하거나,  `delete arr[1]` 로 원소를 삭제하는 경우,  
`arr` 에는 `undefined` 가 생긴다. ( 첫번째의 경우에서는 인덱스 5에서, 두번째는 1에서 발생)  
이 상태에서 `length` 값에 접근하면 전자는 7, 후자는 5가 저장되어 있을 것이다.  
하지만 실제 원소의 개수는 전자는 6개, 후자는 4개이다.  

## 연산자

---

표현식이란 ***어떤 값으로 평가(evaluation) 되는 것*** 이다.  
평가란 표현식의 값, 변수 함수등의 값을 바탕으로 식의 값을 계산하는 행위라고 한다.  
연산자(operator) 와 표현식을 조합하여 복잡한 표현식을 만들어 낸다.  
연산자외의 연산되는 표현식을 피연산자(operand) 라고 한다.
피연산자의 수에 따라 단항, 이항, 삼항 연산자로 분류하기도 한다.  
다른 언어처럼 연산의 우선 순위가 존재한다.

- 산술 연산자  
피연산자가 숫자일 때, 산술 연산자라고 한다.  
대체로 다른 언어와 비슷하나, 몇가지 유의점이 존재한다.  
모든 연산이 64비트 ***부동소수점*** 연산이다. 이로 인해 다른 언어와는 다른 결과가 나올 수 있다.  
또한, 계산 불가일 때, 오류 대신에 `NaN` 값이 반환된다.  
정수 나눗셈은 지원하지 않고, 무조건 부동소수점으로 반환된다.
나머지 연산자의 피연산자로서 부동소수점이 가능하다.
+ 연산자는 피연산자 중 하나가 문자열이면 무조건 반환도 문자열이다.
그외, ++, - -, +=, -=, 등등은 역시 지원한다.
- `Math` 객체의 다양한 프로퍼티  
자연로그의 밑수, 2의 자연로그, 파이, 제곱근 등의 자주 쓰이는 값이 프로퍼티로 존재하기도 하며,  
절댓값, 삼각함수, 제곱근, 로그함수 등등 을 지원한다.

소수에 대한 연산은 항상 정확도에 대한 문제가 발생할 수 있기 때문에 오차범위에 대한 고려가 필요하다.

- 문자열 관련 연산자  
문자열에 대한 + 연산은 파이썬과 유사하다.
문자열을 다루기 위해서 `string` 객체로 변환해주면 유용한데, 이 과정을 ***래핑(wrapping)*** 라고 한다.  
다양한 메소드가 있는데, 예시로 특정 문자가 있는지, 인덱스는 어디인지, 길이는 얼마인지, 교체, 제거 등등 다양하다.  
특이하게 문자열에도 `String` 객체의 메소드를 활용가능한데,  
이는 자바스크립트 내부적으로 문자열을 일시적으로 ***래퍼 객체*** (wrapper object) 로 변환하고,
처리 후에는 삭제하기 때문에 가능하다. 예시로

```jsx
var str = "hello world!";
console.log(typeof(str)); // string
console.log(str.length); // 12
console.log(typeof(str)); // string
```

`str` 은 분명 `string` 원시 타입이지만, `str.length` 를 통해 프로퍼티에 접근하고 실제로 작동한다.
이는 `str` 가 임시로 `new String(str)` 을 통해 `string object` 가 되고, `str.length` 출력 후에는
가비지 콜렉터에 의해 제거된다. 따라서 `str` 은 여전히 `string` 원시 타입인 것이다.  

문자열을 표현하는 방법으로 유니코드가 있는데, 이 중 특이하게 두 개의 유니코드로 이루어진 ***써로게이트 페어*** 라는 것이 존재한다. 이는 더 많은 문자를 표현하기 위한 하나의 방법이다.
써로게이트 페어에서 유니코드로, 유니코드에서 써로게이트 페어로 변환하는 공식이 각각 존재한다.

- 관계 연산자와 논리 연산자  
대체로 다른 언어와 비슷하나, `===` , `!==` 이라는 연산자가 있다.
이 연산자는 값뿐만 아니라 ***타입*** 에 대한 검사를 같이 한다.
또한 `==` 에서도 조심해야 할 점이 있다.

```jsx
var a = [1, 2, 3];
var b = [1, 2, 3];
console.log(a == b); // false

```

변수 `a`, `b` 는 객체 타입 변수로 타입은 같으나, 참조로 이루어지기 때문에, 서로 다른 메모리 주소로 `false` 가 뜨게 된다.
특이하게 `NaN` 의 경우는 `NaN === NaN` 의 결과가 `false` 로 예외이다. 즉, `x !== x` 를 만족하는 유일한 예외이다.

- `&&`, `||` 의 단락 평가(short-circuit evaluation)
첫번째 피연산자로 결과가 **확정** 되면, 두번째 피연산자는 검사하지 않는다.
위 내용은 다른 언어에서도 많이 지원한다.

하지만, `&&`, `||` 은 자바스크립트에서는 반환값이 조금 다르다.
보통은 `True, False` 에 해당하는 값을 반환하는 반면,
자바스크립트는 **마지막으로 평가한 값 자체** 를 반환한다.
활용한 예시로는 다음이 있다.

`var time = var1 || var2 || 12;`

다음의 표현식은 `var1`, `var2`, `12` 순의 우선순위를 가진 상태로 `time` 변수에 저장된다.
이는 마지막으로 평가한 값을 반환하기 때문에 가능한 코드이다.

## 비트연산

---

기본적인 연산을 비슷하게 지원한다.

`&` : 논리곱(AND)
`|` : 논리합(OR)
`^` : 베타적 논리합(XOR)
`~` : 부정(NOT)

비트 시프트 연산도 지원하나… 유의점이 존재한다.

`>>`, `<<` 같은 연산자는 **부호 있는** 시프트이며,
`>>>`, `<<<` 같은 연산자는 **부호 없는** 시프트이다.

예시로 `var a = 0b10100;` 라고 하자.
이 때 `a >> 2` 는 `0b11101` 이며, `a >>> 2` 는 `0b00101` 이 된다.

## 기타 연산

---

`typeof`, `? :`, `delete`, `new`, `in`, `instanceof`, `eval` 등등이 있다.

`new` 는 새로운 **객체** 를 생성한다.
`in` 은 특정 프로퍼티가 해당 객체에 있는지를 판별해준다. `${property} in ${obj}` 의 형식이다.
`instanceof` 는 객체의 종류를 확인한다. `${obj} instanceof ${constructor}` 의 형식이다.
`eval()` 은 `()` 안의 문자열을 자바스크립트 코드로서 실행한다. `eval("3 + 5")` 는 8을 반환한다.

## 명시적 타입 변환

---

- 숫자 → 문자열
    - `+` 연산자 사용하기
    - `Number` 의 메소드인 `toString` 등등을 활용한다.
    - `String()` 함수를 활용한다.
- 문자열 → 숫자
    - 묵시적 변환  
    `var s = “2”` `s = s - 0;`, `+s` 등등
    - `parseInt`, `parseFloat` 를 활용, 이 때 처음 단어만 바꾼다.
    - `Number()` 함수 활용
- 논리값으로 변환
    - `!! x`
    - `Boolean(x)`

## 웹 브라우저에서의 입출력

---

- 대화상자

전역 객체인 `window` 에서 `alert`, `prompt`, `confirm` 등을 활용할 수 있다.  
각각 조금씩 그 특징이 다르다.
`alert` : 인수로 받은 문자열을 띄워준다.  
`prompt` : 문자열을 입력받는다. 이 때 무조건 문자열로 받기 때문에 필요하면 형변환이 필요하다.  
이는 파이썬의 `input()` 과 유사하다.
`confirm` : `확인 / 취소` 의 두가지 상자를 제시하고, 각각 `true/false` 를 반환한다.

- console

다양한 정보를 콘솔 창에 출력해준다. 간단하기 때문에 디버깅 용도로 많이 활용된다.  
`log`, `info`, `warn`, `error` 는 모두 비슷한 역할을 하지만, 앞에 추가적인 표시가 붙는 등 조금씩 다르다.
`%d` 등의 서식 지정자를 사용할 수 있다.  

`.dir` 는 인자의 프로퍼티를 콘솔 창에 보여준다.  
`.time(${name})`, `timeEnd(${name})` 는 `name` 에 해당하는 타이머를 시작, 및 종료하는 메소드이다.  

## 이벤트

---

우리가 사용하는 웹 브라우저에는 어떤한 행동들이 있다.  
마우스를 움직이거나, 클릭을 하거나, 키보드를 친다거나 하는 행동들을 **이벤트** 라고 할 수 있다.

이러한 이벤트 발생시에 실행하는 프로그램을 **이벤트 주도형 프로그램** (event driven program) 이라고 한다.  
**이벤트 처리기** 는 이러한 이벤트시에 발동하는 함수를 의미한다.  
함수를 이벤트 처리기로 만드는 방법은

- HTML 요소의 속성으로 등록하기
- DOM 요소의 프로퍼티로 등록하기
- `addEventListener` 메소드 사용하기

가 있다고 한다.

- HTML 요소의 속성에 등록하기

HTML 작성 중 사용하는 태그 중 일부는 이벤트 처리기를 지원한다.  
이들에 함수를 등록하면 해당 이벤트 발생시 등록된 함수를 시행하도록 할 수 있다.
예시로는,  
`onclick`, `ondbclick`, `onkeydown`  
등등이 존재한다.  
하지만, HTML 과 javascript 의 코드가 섞인다는 점에서 좋은 방법이라고 할 순 없다.

- DOM 에서 가져온 HTML 요소에 지정하기

**DOM** (Document Object Model) 은 자바스크립트 등의 프로그램이 HTML 요소를 조작하게 해주는 인터페이스라고 한다.  

주요 객체로 `window` , `document`, `요소 객체` 가 있다.

- `window`

웹브라우저 윈도우 혹은 탭 하나를 가르킨다.

- `document`

HTML 문서 전체를 가르킨다. HTML 요소를 가져오거나 새로 만드는 등 다양한 기능을 제공한다.

- `요소 객체`

HTML 요소를 가르키는 객체이다.

이들을 바탕으로 이벤트 처리기를 만든다.  

`window.onload` 를 통해, 프로그램의 초기 설정을 해준다.  
이 코드는 아직 HTML을 읽기 전이므로, 읽고 나서 처리하도록 해준다.  
이 곳에서 다양한 기본 설정을 해주게 된다.  

그 후 `document` 의 다양한 메소드를 활용해 HTML 요소를 저장한다.  
예시로 `var button_1 = document.getElementById("button");` 은  
HTML 에서 `id` 가 `button` 인 요소를 가지고 와 `button_1` 에 저장하게 된다.  
이제 위와 비슷하게 이벤트 처리기를 등록할 수 있다.  

`button_1.inclick = displayTime` 같이 `button` 의 **이벤트 처리기 프로퍼티** 를 활용하여 만들 수 있다.

또한 기본적으로 이벤트 처리기 프로퍼티는 `null` 로 저장되어 있기 때문에,  
제거시에는 `null` 을 대입하는 것으로 처리한다.

- `window` 객체를 활용한 타이머 만들기

`setTimeout(${func_name}, ${interval})` : `func` 을 `interval` 후에 실행한다. (**한번만** 실행한다.)  
만약 `clearTimeout` 에 넘기면, 함수 실행을 취소한다.  

`setInterval` : `interval` 간격으로 함수를 **반복** 실행한다.  
만약 `clearInterval` 에 넘기면, 함수 실행이 취소된다.  

두 함수 모두 첫번째 인자로 **문자열** 이 가능하다. 이 때는 자동으로 `eval()` 을 실행시키고 넘긴다.  

## HTML 요소를 동적으로 읽고 쓰기

---

요소 객체의 `innerHTML` 을 통해 요소의 HTML 을 변경할 수 있다.  
`var.innerHTML = value` 일 때, HTML 문서에서의 `var` 의 HTML 내용은 `value` 로 바뀐다.

`input` 태그의 `value` 프로퍼티 등을 할용해서 웹에서 입력된 값을 가지고 와 활용할 수 있다.  
예를 들어 HTML 문서에 `<input type="number", id="height">` 일 경우,  
`document.getElementById(”height”).value` 를 통해 변수에 저장해줄 수 있다.  
단, 문자열이기 때문에 숫자로의 변환이 필요하다.

`document.write` 를 통한 출력도 가능하지만, 오늘날에는 잘 쓰이지는 않는다.

## `canvas` 를 활용한 컴퓨터 그래픽스 ~~그림그리기~~

---

`canvas` 는 저수준 API 로 기본적인 기능만을 제공한다.  
또한 즉시 실행형이기 때문에 바로 실행된다는 점이 특징이다.

`canvas` 를 사용하기 위해서는 HTML 문서에 `canvas` 요소를 배치해야만 한다.  
그 후 javascript 를 통해 불러와서 편집하면 된다. (`getElementById` 를 활용할 수 있다.)  

그 후에는 **렌더링 컨텍스트** 라는 것을 `canvas` 에서 가져와야 한다.  
이는 위에서 가져온 `canvas` 요소에 `.getContext("${name}")` 을 통해 가져올 수 있다.  
`name` 이 `2d` 이면 2차원으로, `webgl` 이면 WebGL 을 활용한 3차원 그림을 그릴 수 있다.  
이 때 가져온 컨텍스트를 저장하는 변수로 `ctx` 를 사용하는 것이 관례라고 한다. (context의 약자이다)  

이 변수 위에서 다양하게 그림을 그릴 수 있다.  

기본 도형을 바로 그릴 수도 있다.  
`strokeRect`, `fillRect` , `arc`, `arcTo` 등등은 위치와 크기를 지정해주면 그에 맞게 그려준다.  

반면에 직접 선으로 그릴 수도 있다.  
`moveTo` 를 활용하면 펜을 들고 움직이는 결과를 만들어낼 수 있다.  
반면, `lineTo` 를 활용하면 펜으로 그리면서 움직이는 결과를 만들어낸다.

`ctx` 의 프로퍼티를 설정함으로서, 그림의 속성을 설정할 수 있다.  
그림을 그리는 부분에서는 설정 못한다는 점을 유의하자.  
`strokeStyle`, `fileStyle` 등 색상을 지원하며, `globalAlpha` 를 통한 투명도 조절도 가능하다.  
등등 다양한 기능을 지원한다.  

- 그림 읽어 들이기

이미지를 처리하는 방법 설정 후, 이미지를 등록하는 것이 일반적이다.  
이는 다른 비슷한 상황에서도 유사하므로 잘 기억하는 편이 좋다.

이미지를 위한 `Image` 객체가 필요하다. 객체이므로 `new` 키워드를 사용해야 한다.  
그 후 해당 객체의 `src` 프로퍼티를 설정해주어야 한다.  
이는 로컬로 파일 위치를 통한 URL,  
또는 `canvas` 의 그림을 가져오려면 `canvas.toDataURL` 를 사용하면 된다.  
이후 `ctx.drawImage()` 를 통해 그림을 그릴 수 있다.

단, 읽어들이는 중에 그리라고 요청하면 실패하므로, `.onload` 프로퍼티에 이벤트 처리기에서 실행한다.

`drawImage` 는 인수의 개수에 따라 각각 다르게 작용되며, 크게 3가지 방법이 존재한다.

픽셀을 제어하는 다양한 메서드도 지원한다.

- `getImageData(x, y, width, height)`

위 메소드로 받은 변수(`imageData` 라고 가칭) 은 3가지 프로퍼티를 가진다.  
`width`, `height`, `data` 이다. `width` , `height` 는 픽셀 단위 너비, 높이를 가진다.  
`data` 는 각 픽셀당 R, G, B, A(alpha : 투명도) 로 저장된다. 즉, `data` 는 $4 \times width \times height$ 의 길이를 가지는 배열이다.  

- `createImageData`

인자가 `width` `height` 일 때는 그 사이즈의 객체를 만든다. 이 때, 각 픽셀은 검정색으로 초기화 되어있다.  
인자가 `anotherImageData` 일 때는 그 데이터에 맞는 객체로 만든다. 하지만, 이미지를 복사하지 않고,  
투명한 검정색으로 초기화된다.

## 제어문

---

`if-else` , `switch` , `while`, `for` 는 C와 동일하다.  

`for ${var} in ${obj}` 는 매 순회마다 `var` 에 `obj` 의 프로퍼티를 부여한다.  
`break` 나 `continue` 도 비슷하지만, `break ${label_name}` 으로 사용할 수 있다.  
이들은 label 된 해당 문장으로 돌아간다.  
문장에는 `labal : sentence` 형식으로 labeling 가능하다.

## 망델브로 집합 예제

---