# week1

---

자바스크립트의 주요한 특징 

1. 인터프리터 언어이다.
이로 인해 느리다고  판단할 수도 있지만, JIT 컴파일러를 통해 실행 속도를 높였다고 한다.

1. 객체 지향을 지원한다.
단, C++, java 와는 다르게 클래스가 아닌, 프로토타입을 통해 지원한다.
프로토타입은 매소드와 프로퍼티를 동적으로 추가, 삭제 가능하다고 한다.

1. 동적 타입 언어이다.
자바스크립트는 변수 타입이 존재하지 않는다. 
파이썬의 경우 명시하지는 않지만, 한번 정해진 변수에는 타입이 고정되는데 ( 변환은 가능하지만),
설명으로는 동적으로 변경가능하다는데, 이것이 파이썬과 같은 의미인지는 알아봐야 할 거 같다.

1. 함수가 일급 객체이다.
일급 객체란 [영문 위키피디아](https://en.m.wikipedia.org/wiki/First-class_citizen)에 따르면, 다른 객체처럼 연산이 적용가능한 객체를 의미한다.
즉, `int`, `float`, `double` 등의 자료형에서처럼 기본 연산이 가능하며, 또한 함수의 인자, 반환값으로도 가능하다는 의미이다.

1. 함수가 클로저를 정의한다.
클로저에 대해 한 [사이트](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)를 참고해본 결과(다 이해하기는 좀 어려웠고…)
다른 언어랑은 스코프의 작동방식이 조금 다른 것 같았다. 또한, 이를 통해 비공개 메소드를 만든다는 점은 흥미로웠다.

## 변수

---

변수 선언은 기본적으로 `var` 이라는 키워드를 사용한다.
타입의 구분이 없으므로 모든 데이터를 저장가능하다.
만약 선언후 초기화하지 않는다면, `undefined` 라는 값이 저장된다.
`var` 로 선언하지 않고 바로 대입이 가능은 하다고 하지만… 전역변수로 선언되며, 오류를 일으킬 가능성이 높으므로 권장하지 않는다.

`호이스팅(hoisting)` 이라는 기능에 의해, 위치상 선언보다 사용이 먼저이더라도 오류가 나지 않고 실행된다.
단, 선언과 초기화가 동시에 이루어지면, 초기화된 값이 아니라 `undefined` 을 반환한다.

숫자는 기본적으로 64비트 부동소수점(`double`)으로 저장된다. 
또한 각종 2진법, 8진법, 16진법 표기법을 지원한다. 단, 2진법, 8진법은 ES6부터 지원한다는 점은 유의해야한다.

읽기 전용의 특별한 문자열이 존재한다.
`Infinity` : 양의 무한대, `const long long INF = 1 << 60` 과 비슷하다.
`NaN` : 부정 값..? (Not a Number), 0을 0 으로 나눈 결과값이라고 한다.

여기서부터는 모두 `Number` 의 프로퍼티이다.
`POSITIVE_INFINITY`, `NEGATIVE_INFINITY`, `MAX_VALUE`, `MIN_VALUE`, `NaN`,
`EPSILON`(대충 굉장히 작은 양의 소수), `MIN_SAFE_INTEGER`, `MAX_SAFE_INTEGER` 

문자열은 `’’`와 `””` 은 구분하지 않는다. 

이스케이프 시퀀스는 비슷하게 지원한다.

특수한 값으로는 `undefined` 와 `null` 이 존재한다.
`undefined` 는 ***값이 할당되지 않음*** 을, `null` 은 ***아무것도 없음*** 을 의미한다. 

## ECMAScript6 부터 추가된 데이터 타입

---

심벌
`var sym1 = Symbol();` 의 형식으로 만들 수 있다.
이 때, `sym1` 에는 고유의 값이 저장된다. (하지만, 내부에 저장된 값은 `undefined` 이다.)
이를 통해 코드의 가독성을 높일 수 있다.
예를 들어,  몇 권의 책을 숫자로 이루어진 코드로 구별하기로 했다고 하자.
모던자바스크립트입문 = 1, 리액트 어쩌구저쩌구 = 2…
어떤 책이 모던자바스크립트입문인지를 확인하고 싶다고 가정할 때, 
`book == 1` 로 확인할 것이다. 하지만, 이 코드만으로는 왜 1인지, 1이 무엇을 의미하는지 파악하기 어렵다.
그래서 그 대신에 `모던자바스크립트입문 = Symbol();` 이라고 선언한다면,
`book == 모던자바스크립트입문` 은 좀 더 직관적인 코드가 된다.
또한 () 안의 인자는 그 심벌에 대한 부가설명을 추가해줄 수 있다.

또한, 같은 심벌을 공유하고 싶은 경우에는 `Symbol.for(부가설명)` 을 통해 같은 부가설명인 심벌에 대해 공유할 수 있다.
주의) `Symbol(“club”) != Symbol.for(“club”);` 이다.
따라서, 심벌을 공유할 생각이라면 처음부터 `Symbol.for()` 을 사용해야 한다.

템플렛 리터럴

문자열 리터럴과 비슷하지만, 앞뒤로 ```` 로 감싼다는 점이 다르다.(`’’` 이나, `””` 이 아니다)
문자열과 다른 점은 입력한 그대로 출력할 수 있다는 것이다.
예를 들어 이스케이프 시퀀스인 `\n` 을 사용하지 않고, `enter` 를 통해 줄바꿈을 출력해 줄 수 있다.
물론 이스케이프 시퀀스는 사용가능하며, 만약 이스케이프 시퀀스를 그대로 출력하려면,
`String.raw``;` 로 표현해주면 된다. 
만약 변수를 추가하고 싶다면, `${…}` 를 사용해주면 된다. 

## 객체

---

원시 타입(앞에서 한 숫자, 문자열, 심벌…) 을 제외하고는 모두 객체이다.
파이썬에서는 모든 것이 객체라고 표현하는 것과는 차이가 있다.

객체 : 이름과 값을 한 쌍으로 묶은 데이터가 여러 개임
포함된 데이터쌍 하나를 ***프로퍼티*** 라고 한다.

객체 리터럴로 생성가능하다.
`var ${name} = { ${key} : ${value}, … }` 의 형식으로 생성가능하다.
접근은 `name.key` 혹은 `name[key]` 로 접근가능하다.
없는 `key` 로 접근시 `undefined` 를 반환한다.

생성 후 프로퍼티 추가가 가능하다. `name.key = value` , `name[key] = value` 의 형식이다.
`delete` 를 통해 제거도 가능하다. `delete name.key`, `delete name[key]`

`in` 연산자로 프로퍼티가 존재하는지 확인가능하다.
`key in name` 의 형식으로 `true / false` 를 반환한다.
주의점은 상속받은 모든 프로퍼티를 검사한다는 점이다.

객체는 ***참조*** 함으로서 저장한다는 점을 유념하자.

## 함수

---

`function ${name} (${var1}, ${var2}, ... ) {... return ${value} }` 의 형식이다.
대체로 python 과 유사하다.

함수의 사용이 선언보다 앞에 위치해도 잘 작동한다.

함수도 객체이므로, 함수를 참조하는 변수를 선언할 수 있다.
`var ${name} = ${function_name}` 의 형식으로 `name` 은 `function` 을 가르키는 변수이다.

유의할 점은 인수로서 넘기는 변수가 객체일 때이다.
객체는 기본적으로 ***참조*** 를 활용한다.
이에 함수는 ***참조값*** 을 전달받게 되고, 이는 복사된 변수의 변경가능성을 유발한다.

- 만약 함수가 받아야 할 변수가 너무 많으면 어떻게 간단하게 해결할 수 있을까?
함수가 받을 여러개의 변수들을 하나의 객체로 담아서 전달하면 된다.
이런 방법은 함수에서는 객체만 받으면 되므로 코드가 깔끔해지며,
순서에 구애받지 않아도 되므로 편하다.
단, 객체로 전달하기 때문에 원본이 훼손될 수 있다는 점을 유의해야 한다.

변수의  스코프는 다른 언어와 크게 다르지 않으나, ***변수의 끌어올림*** 도 생각해야 함을 주의한다.
전역 변수는 `${name} = ${value}` 즉, `var` 을 쓰지 않고 변수를 만들면 된다.

`let` 은 `var` 처럼 변수를 만들지만, 그 스코프가 `{}` 으로 한정된다는 점이 다르다.
`const` 는 상수를 만들 때 사용된다. 특이점은 객체에는 `const` 를 붙여도 프로퍼티 변경이 가능하다…

또한 함수는 리터럴로 선언하는 것이 가능하다.
`var ${name} = function(${var1}, ${var2}, … ) { … return ${value}; };`
익명 함수, 무명 함수라고 불리며, name이라는 변수에 함수 객체의 참조 형식으로 저장된다.
단, 할당된 후에 사용가능하므로, 이러한 형태의 변수는 ***끌어올림*** 이 적용되지 않음을 주의한다.

메서드에서 객체의 프로퍼티를 사용할 때는 `this` 를 객체이름 대신 사용해주면 된다.
객체 내의 메서드를 만들 수 있다. 기본적으로 자바스크립트는 프로퍼티와 메소드를 구분하지 않는다.

## 객체를 만드는 다른 방법

---

앞에서 객체를 만드는 방법으로 객체 리터럴을 알아보았다.
하지만 이런 방법은 비슷한 객체(프로퍼티는 같으나, 그 값만 다른 객체들) 을 만들 때는 
매번 코드를 반복하기 때문에 좋은 방법이라고 할 수는 없다.
다른 언어에서는 클래스 생성자라는 문법으로 하나의 틀을 제공하는데, 
사실 자바스크립트에는 생성자가 따로 존재하지는 않는다.
대신에 함수를 생성하는 방식을 가지고 있다.
`function ${obj_name} ( ${property_1_value}, ${property_2_value}, … ) {this.property_1 = property_1_value; … }` 의 형식으로 함수를 만들고,
`var ${instance_name} = new ${obj_name} (val_1, val_2, …);` 으로 `new` 키워드를 통해 만든다.

자바스크립트는 기본적으로 내장된 객체들을 지원한다.
또한 객체는 종류에 따라 ***네이티브 객체, 호스트 객체, 사용자 정의 객체*** 로 나뉜다고 한다.

## 배열

---

배열은 `var ${name} = [ val_1, val_2, ... ];` 으로 배열 리터럴을 사용할 수 있다.
인덱스는 0-base 이며, 특이하게 배열 리터럴에서 값 생략이 가능하다.
예를 들어, `var arr = [0, 1, , 3, 4];` 로 생성한다면, 2번째 index에는 `undefined` 가 저장된다.
배열은 `length` 라는 프로퍼티가 존재하는데, 이는 일반적으로 다른 언어의 배열처럼 길이를 저장하지만,
유의점이 존재한다. `length` 는 실제로는 최대 인덱스 + 1 라는 값을 가지는데,
이것이 실제 길이와는 다른 경우가 존재한다고 한다. ( 아마 희소 배열이라는 것 같다.)
또한 다른 언어와는 달리 배열은 메모리의 연속된 주소가 아닌 객체로 구현된 가상의 배열이다.
그래서 원소 접근을 `arr["2"]` 식의 접근이 가능하다.
추가로는 `arr.push(val)` 이 가능하고, 삭제는 `delete arr[1]` 의 형식으로 가능하다.
이 때 주의할 점은 삭제시 그 위치는 `undefined` 로 바뀐다는 것이다. 
즉 길이 `length` 의 값이 변하지는 않는다.
그 예시로는 희소 배열이 되는데,
일반 배열에 원소를 추가, 삭제하는 경우 발생할 수 있다.
예시로 `var arr = [0, 1, 2, 3, 4]` 를 들어보자.
이 배열에 `arr[6] = 6`  이라는 원소를 추가하거나,  `delete arr[1]` 로 원소를 삭제하는 경우,
`arr` 에는 `undefined` 가 생긴다. ( 첫번째의 경우에서는 인덱스 5에서, 두번째는 1에서 발생)
이 상태에서 `length` 값에 접근하면 전자는 7, 후자는 5가 저장되어 있을 것이다.
하지만 실제 원소의 개수는 전자는 6개, 후자는 4개이다.