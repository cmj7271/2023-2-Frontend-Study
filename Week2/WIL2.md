# week2

---

## 함수

---

함수 정의 방법에는 4가지가 있다.

1. 함수 선언문으로 정의하기

`function name (var1, var2, ... ) { ... return ret; }`   

1. 함수 리터럴

변수에 직접 저장하는 것도 가능

`var name = function (var1, var2, ...) { ... return ret; }`

1. `Function` 생성자로 정의할 수 있다.

`var name = new Function("var1, var2, ...", "... return ret")`

1. 화살표 함수 표현식

`var name = var1, var2, ... => ret`

이것은 ECMAScript6 부터 추가된 문법이다.

하지만, 밑의 3가지 방법은 참조를 할당해야 사용가능하기 때문에,  
선언보다 활용이 먼저 나오면 안된다.  

- 중첩 함수
    
    단, 함수 내부에서만 중첩 가능하므로, 함수 내부의 `if` , `while` 문 내부에서는 정의를 할 수 없다.  
    내부 함수에서 외부 함수의 변수를 가져올 수 있다는 특징이 있다.
    

- 함수를 호출할 수 있는 방법
    1. `()` 사용  
    `var s = square(5)` 같은 사용이 있다.
    2. 메서드 호출  
    `obj.m = function() {...}; obj.m();`  
    이는 본질적으로 1번과 같은 방법이다.
    3. 생성자를 사용하는 방법  
    `var obj = new Object();`  
    4. `call` `apply` 를 사용하는 방법
    
- 즉시 실행 함수
    
    정의와 동시에 함수를 실행할 수 있는 방법이다.
    
    1. `(function() {...}) ();`
        
        `()` 로 묶으면 괄호 안을 함수 정의식으로 평가하여 함수값으로 바뀐다.
        
    2. `+function() {...} ()`
    3. `(function(a, b) {...}) (1, 2);` 으로 인자를 넘길 수 있다.
    
    즉시 실행 함수의 결과를 변수에 저장할 수 있다.
    

## 함수의 인수

---

자바스크립트는 함수에 지정된 인자보다 많게도 적게도 넘길 수 있다.  
각각의 경우에 어떤 일이 일어나는지 알아보자.

1. 인수가 적을 때 (인수의 생략)  
    
    생략한 인수는 기본적으로 `undefined` 으로 전달된다.  
    이러한 특성을 활용해 기본값을 설정할 수 있다.  
    `b = b || value` 의 형식으로 `value` 값으로 설정가능하다.  
    원리는 `||` 은 앞에서 `true` 면 앞의 값을 반환하므로,  
    `undefined` 가 아니라면, `b` 값이 유지되고,  
    아니라면, `value` 값을 통해 `true` 가 되므로 `b = value` 가 될 것이다.
    
2. 인수가 많을 때 (`Arguments` 객체 활용하기)  
    
    `Arguments` 는 함수가 인자를 받을 때 자동적으로 저장된다.  
    유사배열객체로서 `[]` 를 통해 접근가능하다.  
    프로퍼티로 `.length` , `callee` (현재 실행하는 함수의 참조) 가 존재한다.  
    **주의**  : `callee` 는 더이상 사용하는 것을 추천하지 않는다. ([참고링크](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)) 되도록 사용을 피하도록 하자.
    
    `Arguments` 는 유사배열객체로 객체로 바꾸는 방법이 있다.  
    `var params = [].slice.call(arguments);` 를 통해 가능하다.  
    배열 메소드인 `slice` 와 `call` 메소드는 후술할 예정이다.
    

### 재귀함수

---

일반적인 재귀함수처럼 사용가능하다.  
만약 함수 리터럴로 정의한 함수를 재귀 호출하려면,  

- 함수 리터럴에 이름 붙이기
    
    `var fact = function f(x) { ... return f(x - 1) * x; }`  
    또는 `arguments.callee` 로도 가능하나 위에서 말했듯이 지양하는 편이 좋다.
    

재귀 함수를 사용할 때는 주의할 점들이 있다.

1. 재귀 호출이 ***반드시*** 멈춰야 한다.  
    
    함수 호출이 멈추도록 하는 기본값 코드가 존재해야 한다.  
    존재하지 않으면 프로그램이 멈추지 않으므로 유의해야 한다.
    
2. 재귀 함수는 피할 수 있으면 피하는 편이 좋다.  
    
    재귀함수는 그자체로 컴퓨터 리소스를 많이 사용하기 때문에,  
    `for` 문이나 `while` 문으로 해결할 수 있다면 그 편이 더 효율적이다.  
    따라서 문제자체가 재귀적으로 정의되어 있는등, 재귀가 문제를 간단하게 해줄 때 사용한다.
    

## 프로그램의 평가와 실행 과정

---

엔진은 **코드**를 만나면 **평가(Evaluation)** 하고 **실행문맥(Execution Context)** 으로 만든다.  

이 때 실행 가능한 코드는 크게 3가지로 나뉜다.

- 전역 코드
- 함수 코드
- eval 코드

전역 코드는 `window` 객체 아래의 함수, 함수 코드는 함수, eval 코드는 eval 함수를 의미한다.

이러한 구분의 이유는 실행 문맥을 초기화하는 환경이 달라서라고 한다.  
그중 특히 eval 코드는 **랙시컬 환경(Lexical Environment)** 이 아닌 다른 곳에서 실행된다.  

이에 대한 내용은 책에서 생략한다고 한다. 조금 [자료](https://www.notion.so/d622c885aa884975b3e3ad9f79cff803?pvs=21)를 찾아보니 사용자체를 추천하지 않는다.  
보안 상의 이유와 속도 이슈로 인해서 가급적 사용하지 않는 것을 추천하고 있다.

- 실행문맥 (Execution Context)
    
    실행 가능한 코드가 실행되고 관리되는 영역이다.  
    필요한 모든 정보가 여러 컴포넌트에 나뉘어 관리된다.
    
    - 컴포넌트
        
        여러 컴포넌트 중 주요 컴포넌트는 다음과 같다.
        
        - 렉시컬 환경(Lexical Environment) 컴포넌트
        - 변수 환경(Variable Environment) 컴포넌트
        - 디스 바인딩(This Binding) 컴포넌트
        
        렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 거의 비슷하다.  
        (`with` 문을 사용할 때는 조금 다른 듯하다.)
        
        디스 바인딩 컴포넌트는 함수를 호출한 객체의 참조가 저장된다.
        

### 렉시컬 환경 컴포넌트

---

렉시컬 환경 컴포넌트

                l ——— 환경 레코드(Environment Record)

                l ——— 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 컴포넌트

환경 레코드 :  

유효 범위 안의 식별자를 기록하고 실행한다.  
($\approx$ ECKAScript3 의 변수 객체(Variable Object) ~~이게뭔데~~)  
자바스크립트 엔진은 유효 범위안의 식별자와 결과값을 바인딩해서 환경 레코드에 저장함  

외부 렉시컬 환경 참조 :

자바스크립트는 함수 내부에서 함수를 중첩해서 정의할 수 있다.  
내부의 함수가 외부의 변수를 접근할 수 있다.  
이 때문에 외부 렉시컬 환경 참조에는 해당 함수를 포함하고 있는 코드가 속한  
렉시컬 환경 컴포넌트에 대한 참조가 저장되어 있다.

**상세 설명**

환경 레코드 :

렉시컬 환경 안의 식별자와 식별자가 가르키는 값이 한 쌍이 되어 저장된다.  
환경 레코드는 **선언적 환경 레코드(Declarative Environment Record)** 와  
**객체 환경 레코드(Object Environment Record)** 로 이루어져 있다.  
이 둘은 저장하는 값의 유형에 따라 다르다.

환경 레코드

ㅣ——— 선언적 환경 레코드

ㅣ——— 객체 환경 레코드

선언적 환경 레코드 :

함수, 변수, `catch` 문의 식별자와 그 실행 결과가 저장된다.

객체 환경 레코드 :

실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.  
(실행 문맥은 실행 가능한 코드가 실제로 실행되고 관리되는 영역으로  
여러 컴포넌트가 나누어 관리한다.)  
별도의 객체로 저장된 정보를 그 객체 전체에 대한 참조로 가져와서  
객체 환경 레코드의 `bindObject` 라는 프로퍼티에 바인드시킨다.

렉시컬 환경 컴포넌트

                l ——— 환경 레코드(Environment Record)

                l                    l ——— 선언적 환경 레코드

                l                    l ——— 객체 환경 레코드

                l

                l ——— 외부 렉시컬 환경 참조(Outer Lexical Environment Reference) 컴포넌트

### 전역 환경과 전역 객체의 생성

---

자바스크립트 인터프리터는 시작한 직후,  
**렉시컬 환경 타입의 전역 환경(Global Environment)** 를 생성한다.  
만약 웹 브라우저에 내장되어 있다면, 웹 페이지를 읽어 들인 후 생성한다.  
최상위 레벨에서의 `this` 는 전역객체를 가르킨다.

### 프로그램의 평가와 전역 변수

---

자바스크립트는 프로그램을 읽은 후, 평가한다.  
이 때 최상단 레벨에서 정의된 `var` 문은 전역 환경의 환경 레코드의 프로퍼티로 추가된다.  
최상단의 함수는 함수 객체로 생성하여 전역 환경의 환경 레코드에 프로퍼티로 기록한다.

전역 변수 —> 전역객체의 실행 문맥에 들어있는 환경 레코드의 프로퍼티  
지역 변수 —> 그 변수가 속한 실행 문맥의 환경 레코드의 프로퍼티  

이처럼 변수와 함수는 평가하는 시점에 환경레코드에 추가되기 때문에,  
프로그램의 평가단계에서는 이미 추가되어 어느 위치에서도 사용가능하다.  
이것이 변수 선언문과 함수 선언문의 ‘끌어올림’ 현상의 원리이다.

`var` 문과 함수 선언문으로 선언한 전역 변수는 [[configuable]] 속성이 `false` 이기 때문에,  
`delete` 로는 제거할 수 없다.  

하지만, `var` 문을 사용하지 않고 변수를 선언한다면,  
디스 바인딩 컴포넌트가 가르키는 객체의 프로퍼티로 추가된다.  
전역 객체의 디스 바인딩 컴포넌트는 전역 객체이므로, 전역 객체의 프로퍼티가 된다.  
또한 [[configuable]] 의 값이 `true` 이기 때문에 `delete` 를 통한 제거가 가능하다.  

### 프로그램 실행과 실행 문맥

---

프로그램의 평가 후, 프로그램이 실행되며, **실행 문맥(Execution Context)** 안에서 실행된다.  
이 실행문맥은 실행가능한코드 별로 생성된다.  

실행 문맥은 **스택** 이라는 구조로 관리된다.  
**push**, **pop** 등의 행위가 존재한다.  

실행 문맥은 전역 코드를 **push** 하기 때문에, 스택 맨 아래에는 전역 코드를 위한 실행 문맥이 존재한다.  
그리고 내부에서의 함수를 실행하기 위해 실행 문맥을 스택에 **push** 하고, 함수의 작업이 끝나면 **pop** 한다.  
이 때문에 여러 중첩 함수에서 내부 함수의 실행 문맥이 외부 함수의 실행 문맥과 겹치지 않는다.  
재귀 함수의 경우도 비슷하며 분명 이름은 같지만 서로 다른 함수로서 **push** 된다.  
실행 문맥 스택을 **호출 스택(call stack)** 이라고도 부른다.

### 싱글 스레드와 멀티 스레드

---

스레드는 프로그램의 처리 흐름이다.  
싱글 스레드는 프로그램 한 개의 처리 방식으로 한개씩 순차적으로 진행한다.  
멀티 스레드는 여러 개의 처리 방식으로 동시에 작업을 여러개 병렬로 실행하는 방식이다.  

자바스크립트는 작업을 싱글 스레드로 처리한다.  
실행문맥 하나의 처리 후 그 다음 문맥 의 방식으로 하나의 실행 문맥 단위로 실행된다.  
따라서 하나의 실행문맥 중 다른 실행문맥은 실행될 수 없다.  

이벤트 처리와 비동기 처리도 비슷하다.  
실행 준비를 마친 이벤트 처리기 함수와 비동기 처리는 **이벤트 큐** 에 대기한다.  
차래대로 삽입하고 처리하면 제거한다.  

웹 브라우저의 API 인 Web Worker 를 사용하면 백그라운드에서 다른 스레드를 실행할 수 있다.  
즉, 멀티 스레드 작업이 가능하다.

### 환경 레코드와 지역 변수

---

함수를 호출하게 되면 코드의 작업을 멈추고 **실행 문맥(Execution Context)** 영역을 생성한다.  
실행 흐름이 그 실행 문맥으로 이동한다. 

그 실행 문맥은 **Call stack** 에 push 되고, 실행 문맥에는 **Lexical Environment Components** 가 생성된다.  
렉시컬 환경 컴포넌트는 내부에 환경 레코드를 가지고 있으며, 이 안에는 
대상 함수 내에서 선언된 **중첩 함수** 의 참조와 변수를 기록한다. 
이 환경 레코드는 **사용자가 읽거나 사용할 수 없으며** 다음과 같은 정보를 저장한다.

- 함수의 인자
- 함수 내의 중첩함수의 참조
- 함수 내의 `var` 로 선언한 지역변수
- `arguments`

함수 실행 시, 그 함수의 선언적 환경 레코드(렉시컬 환경/환경/선언적 환경)에는  
이에 대응하는 인수의 값이 설정된다.  
인수가 없다면, `undefined` 로 설정된다.

함수 선언문으로 생성한 함수 안의 지역 변수에는 함수 선언문으로 생성한 함수 객체의 참조가 설정된다.(~~뭔소리지~~) (아마 중첩함수 내부의 변수는 중첩하고 있는 함수에 대한 참조를 하고 있다는 듯하다….)  
`var` 로 선언된 지역변수에는 `undefined` 가 설정된다. (얘는 가르킬 함수가 없으니 `undefined` 인거 같고?)  

함수의 실행 문맥, 렉시컬 환경, 환경 레코드가 생성되면,  
실행 문맥에 있는 **디스 바인딩(This Binding)** 컴포넌트에 그 함수를 호출한 객체의 참조가 저장된다.  
이것으로 `this` 가 결정된다. `this` 는 **동적** 이며, 함수의 호출 상태에 따라 가르키는 객체가 변한다.  
`this` 에 대해서는 뒤에서 추가로 설명한다.

환경 레코드와 `this` 값이 결정되면, 함수의 코드가 순서대로 실행된다.  
이 시점은 지역변수, 함수 선언문으로 선언한 함수 이름이  
**이미 선언적 환경 레코드에 기록 되었기 때문에** (평가하는 시점에서 이미 기록됨)  
어느 위치에서든 사용가능하다. 즉, 변수 및 함수의 호이스팅이 일어날 수 있는 이유이다.  

함수가 종료되어 제어권이 호출한 코드로 넘어간다면, **보통은** 실행문맥과 함께 그 안에 있는  
렉시컬 환경 컴포넌트가 메모리에서 삭제된다.  
하지만, 그 함수의 바깥쪽에 위치한 함수의 참조가 환경레코드에 유지되는 경우에는  
렉시컬 환경 컴포넌트가 메모리에서 제거되지 않는다.  
이 부분은 클로저에서 다시 설명…한다네요….

### `this` 값

---

`this` 의 값은 함수가 호출되어 실행되는 시점에서 결정된다.  
값은 **함수가 호출되었을 때, 그 함수가 속해있는 객체의 참조** 이다.  

```jsx
var tom = {
	name : "Tom";
	sayHello : function() {
		console.log("Hello!" + this.name);
	}
};

tom.sayHello(); // --> Hello! Tom

var huck = { name : "Huck" };
huck.sayHello = tom.sayHello;

huck.sayHello(); // --> Hello! Huck;
```

`huck.sayHello` 는 `tom.sayHello` 를 참조하고 있다.  
이때 `huck.sayHello` 를 호출하면, 이 때의 `this` 는 호출한 함수인 `sayHello` 가 호출하는 객체가  
`huck` 이기 때문에, `this` 는 `huck` 이 된다.  
(주의점 : `sayHello` 는 `function` 객체를 참조하는 일종의 변수로 볼 수 있다.)  

아래는 특정 상황에 `this` 가 가르키는 값을 정리한 것이다.

- 최상위 레벨 코드
    
    전역 객체를 가르킴  
    실행 문맥이 초기화 될 때, 그 안의 디스 바인딩 컴포넌트는 전역 환경을 가르키게 초기화된다.
    
- 이벤트 처리기 안
    
    이벤트가 발생한 요소 객체(이벤트 처리기가 등록된 객체)
    
- 생성자 함수 안
    
    그 생성자로 생성한 객체
    
- 생성자이 `prototype` 메서드 안
    
    그 생성자로 생성한 객체
    
- 직접 호출한 함수 안
    
    전역 객체를 가르킨다.  
    코드에서 객체가 없으므로 초기값인 디스 바인딩 컴포넌트가 전역 객체를 가르키기 때문이다.  
    만약 앞에 객체를 붙여서 호출하면 그 객체를 가르킨다.  
    
    ```jsx
    var a = {};
    a.f = f;
    a.f();
    ```
    
    이 경우 `a` 는 객체이므로 `f` 가 가르키는 `this` 는 `a` 이다.
    
- `apply` 혹은 `call` 메소드로 호출한 함수 안
    
    이 두 메소드는 `this` 가 가르키는 객체를 바꿀 수 있다.  
    즉, 명시적으로 컴포넌트가 가르키는 객체를 설정할 수 있다. (뒤에서 자세히 설명함)
    

### 식별자 결정 : 유효 범위 체인

---

자바스크립트는 다른 언어와 비슷하게 어휘적 유효 범위를 사용하고 있다.  
즉, 전역 변수는 전체에서 접근 가능하며, 외부에서 선언된 변수는 감싸진 내부에서도 활용 가능하다.  
이는 곧 같은 이름의 변수가 위치에 따라 다른 데이터를 가르킬 수 있다.  
이를 결정하는 과정을 **식별자 결정** 이라고 한다.  
짧게 요약하면, 이는 **좀 더 안쪽에 선언된 변수를 사용한다** 이다.  
내부적 메커니즘을 좀 더 살펴보고자 한다.

앞에서 ~~신나게~~ 배운 렉시컬 환경 컴포넌트를 간단하게 요약해보자면,  
해당하는 변수와 객체가 저장되어 있으며(선언적, 객체 환경 레코드)  
그 밖의 범위에서 변수나 객체를 찾기 위한 외부 참조가 존재한다. (외부 렉시컬 환경 참조)  

즉, 처음에는 선언적, 객체 환경 레코드를 찾아보고,  
없으면 외부 렉시컬 환경 참조가 가르키는 곳에서 찾아본다.  

만약 이 과정에서도 존재하지 않는다면, **참조 오류(Reference error)** 가 된다.  
레코드들은 함수를 호출할 때 생성되므로, 실행할 때는 이미 참조와 변수들이 모두 기록되어있다.  

다음은 관련 몇가지 용어이다.

- **속박 변수** : 함수의 인자와 지역변수
- **자유 변수** : 속박변수 외의 변수

- **닫힌 함수** : 속박 변수만을 포함하는 함수
- **열린 함수** : 자유 변수를 가지고 있는 함수

### 가비지 컬렉션(GC)

---

객체 생성시 메모리에서 동적으로 할당된다.  
사용하지 않는 객체는 제때 제거해야 메모리 누수를 방지할 수 있다.  
c/c++ 같이 가비지 컬럭터를 지원하지 않는 언어는 개발자가 수동적으로 관리를 해주어야 한다.  
이 점은 프로그램을 빠르게 실행시킬 수 있다는 장점이 있지만, 메모리 누수에 대한 대처가 중요하다.  
반면 자바스크립트, 파이썬 등은 **가비지 컬렉터** 가 존재하기 때문에 메모리를 자동으로 해체해준다.  
대신, 가비지 컬렉터가 계속 객체를 확인해야 하기 때문에, 프로그램이 느려질 가능성이 존재한다.  

가비지 컬렉터는 다양한 메커니즘으로 작동하는데,  

예전 자바스크립트의 경우는 **참조 카운터 방식** 을 활용했다.  
이는 해당 객체를 참조하는 횟수가 0일때, 제거하는 방식이다.  
하지만, 서로를 참조하는 등의 **순환 참조** 가 발생할 시 제거할 수 없다는 단점이 존재한다.

최근에는 **마크 앤 스윕(Mark-and-Sweep) 알고리즘** 을 활용한다고 한다.  
이는 전역 객체가 참조할 수 없는 객체를 메모리에서 제거하는 방식으로,  
순환 참조 또한 제거 가능하다.  

그 외에도 다양한 방식이 존재한다.

## 클로저(Closure)

---

클로저의 정의  

- 모던자바스크립트  
**자기자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행하는 함수와  
그 기능을 구현한 자료구조**
- MDN
    
    **주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합**
    
- [유튜브 영상에서 참고한 코어 자바스크립트](https://www.youtube.com/watch?v=PJjPVfQO61o)
    
    **어떤 함수 A에서 선언한 변수 a를 참조하는 내부 함수 B를 외부로 전달하는 경우,  
    A의 실행 컨텍스트가 종료된 후에도 변수 a가 사라지지 않는 현상**
    

자바스크립트는 함수를 만나면 아래의 과정을 거친다.  
컴포넌트 구성 —> 코드평가(변수 및 함수를 호이스팅해 컴포넌트에 저장, 외부 렉시컬 환경 저장 지정)  
—> call stack 에 push —> 코드를 한줄한줄 실행

```jsx
function makeCounter() {
	var count = 0;
	return f;
	
	function f() {
		return ++count;
	}
}

var counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

위의 코드를 분석해보면,  
전역 코드에 대한 컴포넌트 구성 및 코드 평가가 이루어진다.  
이과정에서 `counter` 변수와 `makeCounter` 함수가 기록되고, 외부 렉시컬 환경 저장은 `null` 로 저장되고 `call stack` 에 `push` 된다.  

그 후, `makeCounter` 함수를 만나고 이에 대해,  
`count` 변수와 `f` 함수가 기록되고, 외부 렉시컬 환경 저장에는 `Global` 로 저장되고 `call stack` 에 `push` 된다.  
`counter` 변수에는 `f` 를 가르키는 참조가 저장된다.  
함수의 실행이 끝났으므로, `makeCounter` 는 `call stack` 에서 `pop` 된다.

그 후, `console.log` 내부에서 `counter` 에 할당된 `f` 를 실행하게 된다.  
이 때 또다시 `f` 에 대한 컴포넌트 생성되고 변수 및 객체를 기록해야 하는데…  
`count` 에 대한 기록이 존재하지 않으므로 외부 렉시컬 환경 저장을 참조하고자 할 것이다.  
이 때 참조하는 컴포넌트는 위에서의 `makeCounter` 함수에 대한 컴포넌트가 된다.  
`makeCounter` 는 위 과정에서 이미 `pop` 됬지만,  
사실 `makeCounter` 에서 내부의 함수 `f` 를 만났기 때문에 이미 `f` 에는  
위의 `makeCounter` 를 가르키는 외부 렉시컬 환경 저장이 기록되어있다.  
따라서 `makeCounter` 에 있는 `count` 를 참조하여, `count + 1` 을 저장하고 반환한다.

이 때의 `count` 는 오직 `makeCounter` 내부의 `f` 를 통해서만 접근가능하며,  
`makeCounter` 를 통해 새로운 `counter` 를 만들더라도, 전혀 다른 컴포넌트로  
기존의 `count` 에는 접근하지 못한다.  

이는 객체가 가져야 할 속성 중 하나인 **캡슐화** 를 충족시켜 줄 수 있다.  
오직 `f` 를 통한 접근만이 가능하기 때문이다.  
이러한 점을 활용하여 **클로저를 활용한 캡슐화를 만족하는 객체 공장** 을 만들 수 있다.